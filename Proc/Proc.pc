// win32 Visual C 컴파일시 추가
// 프로그램 가장 첫 줄에 추가할 것
#define _CRT_SECURE_NO_WARNINGS

#include "init_display.h"

void DB_connect();
void sql_select();
void sql_insert_customer();
void sql_update_customer();
void sql_delete_customer();
void sql_error(char *msg);

EXEC SQL BEGIN DECLARE SECTION;
   VARCHAR uid[80];
   VARCHAR pwd[20];
EXEC SQL END DECLARE SECTION;

#define getch()  _getch()

void main() {
	//init();
   DB_connect();
   //sql_insert_customer();
   //sql_update_customer();
   //sql_delete_customer();
   //sql_select();
   init_display();
   return 0;
}

void sql_insert_customer(){
	push_esc();
	EXEC SQL BEGIN DECLARE SECTION;
		char c_name1[15];
		char c_phone1[15];
		char c_adrs1[50];
	EXEC SQL END DECLARE SECTION;

	printf("\n고객 이름 : ");
	scanf("%s", c_name1);
	printf("전화 번호 : ");
	scanf("%s", c_phone1);
	printf("주소 : ");
	scanf("%s", c_adrs1);

	EXEC SQL INSERT INTO customer (c_name, c_phone, c_adrs) VALUES ( :c_name1, :c_phone1, :c_adrs1);
	EXEC SQL COMMIT WORK RELEASE;
	
}

void sql_update_customer(){
	push_esc();
	EXEC SQL BEGIN DECLARE SECTION;
		char c_phone[20];
		char c_phone1[20];
		char c_phone3[20];

		char c_name1[15];
		char c_phone2[20];
		char c_adrs1[50];
		int c_point1;
		int c_point2;
	EXEC SQL END DECLARE SECTION;

	printf("변경할 고객의 전화번호 입력 : ");
	scanf("%s", c_phone);

	EXEC SQL select c_name, c_phone, c_adrs, c_point into :c_name1, :c_phone, :c_adrs1, :c_point1
	from customer where c_phone = :c_phone;

	printf("고객이름 : %s, 전화번호 : %s, 주소 : %s, 포인트 : %d", c_name1, c_phone, c_adrs1, c_point1);
	printf("\n변경할 포인트 : ");
	scanf("%d", &c_point2);

	EXEC SQL UPDATE customer SET c_point = :c_point2 WHERE c_phone = :c_phone;
	EXEC SQL COMMIT WORK;

	EXEC SQL select c_name, c_phone, c_adrs, c_point into :c_name1, :c_phone1, :c_adrs1, :c_point1
	from customer where c_phone = :c_phone;

	printf("\n변경 후\n");
	printf("고객이름 : %s, 전화번호 : %s, 주소 : %s, 포인트 : %d", c_name1, c_phone1, c_adrs1, c_point1);
	scanf("%d", &c_point1);
	
	
}

void sql_delete_customer(){
	EXEC SQL BEGIN DECLARE SECTION;
		char c_phone1[20];
	EXEC SQL END DECLARE SECTION;

	printf("삭제 할 고객 전화번호 : ");
	scanf("%s", c_phone1);
	EXEC SQL DELETE customer where c_phone = :c_phone1;

	EXEC SQL COMMIT WORK RELEASE;
} 

void sql_select(){
	EXEC SQL BEGIN DECLARE SECTION;
		int emp_no;
		char e_name[10];
		char job[10];
		int mgr;
		int sal;
		int deptno;

		char c_name1[15];
		char c_phone1[20];
		char c_adrs1[50];
		int c_point1;

		char p_name1[15];
		char p_birth1[15];
		char p_sex1[1];
		char p_neut1[1];
		char p_aleg1[20];

	EXEC SQL END DECLARE SECTION;


	EXEC SQL select empno, ename, job, mgr, sal, deptno into : emp_no, :e_name, :job, :mgr, :sal, :deptno
	from emp where sal = 5000;

	//EXEC SQL select c_name, c_phone, c_adrs, c_point into :c_name1, :c_phone1, :c_adrs1, :c_point1
	//from customer where c_name = 'KimJaeBeom';
	
	EXEC SQL select p_name, p_birth, p_sex, p_neut, c_name, c_phone, p_aleg into :p_name1, :p_birth1, :p_sex1, :p_neut1, :c_name1, :c_phone1, :p_aleg1
	from pet where p_name = 'Happy';

	//EXEC SQL select count(*)


	//printf("emp 테이블에서 연봉이 5000인 사원번호, 이름, 직무, 매니저의 사원번호, 부서번호를 출력\n\n");

	//printf("사원번호 : %d, 이름 : %s, 직무 : %s, \n연봉 : %d, 부서번호 : %d", emp_no, e_name, job, sal, deptno);
	//printf("고객이름 : %s, 전화번호 : %s, 주소 : %s, 포인트 : %d", c_name1, c_phone1, c_adrs1, c_point1);
	//printf("전화번호 : %s", c_phone1); 
	//printf("동물이름 : %s, 동물생일 : %s, 성별 : %s, 중성화 : %s, 알러지유무 : %s, 보호자이름 : %s, 보호자전화번호 : %s", p_name1, p_birth1, p_sex1, p_neut1, p_aleg1, c_name1, c_phone1);
}

void DB_connect() {
   strcpy((char *)uid.arr, "zstB3@//sedb.deu.ac.kr:1521/orcl");
   uid.len = (short) strlen((char *)uid.arr);
   strcpy((char *)pwd.arr, "sedb1234");
   pwd.len = (short) strlen((char *)pwd.arr);
   
   EXEC SQL CONNECT :uid IDENTIFIED BY :pwd;

   if(sqlca.sqlcode != 0 && sqlca.sqlcode != -1405) { //connect
      printf("\7Connect error: %s ",sqlca.sqlerrm.sqlerrmc);
      getch(); 
      exit(-1);
   }
   //printf("Oracle Connect SUCCESS by %s\n\n", uid.arr);
}

void sql_error(char *msg) {
   char err_msg[128];      size_t buf_len, msg_len;
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   printf("\n%s\n",msg);      
   buf_len = sizeof(err_msg);
   sqlglm(err_msg, &buf_len, &msg_len);   
   printf("%.*s\n",msg_len,err_msg);
   getch();
   EXEC SQL ROLLBACK WORK;
   exit(-1);
}